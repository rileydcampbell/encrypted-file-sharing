# encrypted-file-sharing
Implemented a file sharing system similar to dropbox that provides confidentiality, integrity, and authentication for all users.
Designed a security scheme with the use of Google’s UUID library and GoLang’s RSA cryptographic functions.
Successfully demonstrated fundamental security principles in our design document that led our team to finish in the top 5% of students of a 700 person class by protecting against all of the possible malicious security attacks designed by Professor Nick Weaver at UC Berkeley. 

Section 1: System Design

User Struct: contains the username, private asymmetric decryption key, private digital signature key, a fileTable UUID, and a fileTableKey. (uuid.new and fileTableKey is randomBytes) <br />
uuidAndFileKey Struct: contains a FileLoc UUID and a FileKey (uuid.new and randomBytes) <br />
FileTable Struct: contains a mapping from filename to uuidAndFileKey struct <br />
File Struct: contains a mapping from index to uuidAndFileKey struct <br />
FileCompartment Struct: contains bytes <br />
getKeys(masterKey): HMACs master key with “this is HMAC Key” to get HMACKey and HMACs masterKey with “this is SYM Encrypt key” to get symmetric encryption key. Returns both keys. <br />
AuthenticatedEncryption(masterKey, msgToEncrypt): calls getKeys(masterKey) uses the symKey to encrypt msg and appends the HMAC(hmacKey, encryptedMsg). Returns this. <br /> 
Authenticated Decryption(masterKey, msgToDecrypt): calls getKeys(masterKey) to get symKey and HMACKey. Checks if HMACEqual(encryptedMsg, HMACofEncryptedMsg) is true, if so it decrypts the msg with SymKey and returns the decrypted msg.

Section 2: Summary of Encryption Scheme

A user is initialized by creating a User struct. A fileTable is initialized for each user as well. When a user is first initialized there will be no mappings inside the file table. A salted password is created using the Argon2Key(userPassword, userName, 16). Then the public symmetric encryption key and the public digital signature key (generated from calls to PKEKeyGen and DSKeyGen) are stored in the KeyStore with the username. We marshal the user struct containing all of this information and with symKey from getKeys(saltedPassword) we encrypt it along with a randomIV. We use the HMACKey from getKeys to HMAC the encrypted user struct and then append this to the encrypted user struct. This guarantees confidentiality and integrity. We then HMAC the saltedPassword with a string and use the first 16 bytes to generate a UUID and store the encrypted and HMAC user struct in the DataStore. Since the password has sufficient entropy so does the UUID.
A fileTable that contains mappings from filenames to uuidAndFileKey structs is initialized for each user that is created. 16 randomBytes are generated for the fileTableKey and 16 randomBytes are generated for the fileTableUUID and stored in each user’s User struct. The fileTable is then encrypted using the symmetric encryption key from getKeys(fileTableKey) and is HMAC’ed with the HMACKey from getKeys(fileTableKey). These two chunks of bytes are concatenated and stored in the DataStore at the fileTableUUID.

To store a file the user would first need to call GetUser to get the user struct. They pass the function their username and password which then gets salted to recreate the saltedPassword. The UUID of the user struct is then generated from the saltedPassword from an HMAC with a the same string that was used to store the user struct. Once this is successfully retrieved from the DataStore we call authenticatedDecryption(userStructBytes, saltedPassword). The user has the user struct they can call storeFile which takes in a filename and data. We retrieve the fileTable from the dataStore using the fileTableUUID inside the user struct and call authenticatedDecryption(fileTableSymKey, fileTable). To store the file, a random UUID and a random fileKey are generated that are stored in a uuidAndFileKey struct. The map inside the fileTable is set so that map[filename] = uuidAndFileKey struct. The fileTable is then encrypted with authenticatedEncryption again and put in the DataStore at the same UUID. This overwrites the old fileTable with the new one containing the UUID and a symmetric encryption key for the file we are storing. We then create a File struct with uuidAndFileKey struct containing another pair of a randomly generated uuid and a FileCompartmentKey. To start the file index 0 is mapped to this uuidAndFileKey struct. Then call authenticatedEncryption(File struct) and store this in the DataStore at the UUID specified in FileTable. Finally we create a FileCompartment struct that contains the data the user plans to store. We call
authenticatedEncryption(fileCompartment, FileCompartmentKey) and store this in the DataStore at the UUID specified in the File Struct mapping. To append data to a file the data is put into another authenticatedEncrypted FileCompartment Struct that is then reflected in the File struct mapping so that there is a mapping at index 1 of the File. To retrieve an entire file the system concatenates all the data that is connected to the mapping from the File Struct.
The file names remain what the user inputted inside each user’s fileTable struct but this struct is encrypted and MAC’d so no attacker can view the names. The location of the files are not generated from the names but instead from randomly generated UUIDs. In order to share one of these files with another user the owner retrieves the uuidAndFileKey struct for the file then encrypts it with the public encryption key of the recipient. It is then signed with the private digital signature key of the owner and sent to the recipient. The recipient checks the signature with the owner’s public digital signature key and then decrypts the uuidAndFileKey struct with his private asymmetric key. The uuidAndFileKey struct is then added to the recipient’s fileTable struct. So the recipient now has a mapping from file name to the File.

Once a file is shared it can be revoked by anyone. When it is revoked the user retrieves the File struct deletes what was in the dataStore at that previous UUID and then generates a new UUID and symmetric encryption key that will be stored in that users fileTable. The File is then authenticatedEncrypted with the new key and stored at the new UUID in the DataStore.
